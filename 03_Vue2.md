#### 1、什么是 MVVM，MVC？

1、MVVM  
①、M 是 model：指的是后端传递的数据。  
②、v 是 view：指的是视图，也就是所看到的页面。  
③、vm 是 view model：视图模型。它是连接 view 与 model 的桥梁，主
要处理业务逻辑  
2、MVC  
①、M：模型  
②、V：视图  
③、C：控制器，逻辑处理

#### 2、vue 的特点与功能

1、数据的驱动  
2、数据的双向绑定  
3、组件化开发

#### 3、vue 的双向绑定原理，vue 响应式原理，数据的响应式？

vue 采用的是数据劫持结合发布者订阅的模式，通过 object.defineProperty()来劫持 get、set 方法，在数据发生变化的时候发布给订阅者，触发响应式回调。

#### 4、页面的响应式

媒体查询，检测屏幕在多大尺寸的时候干什么事情

#### 5、vue 双向绑定除了 Object 还有什么方法？

用 addEventListener 给元素添加 input 事件，当数据发生变化的时候进行相应的操作

#### 6、v-model 底层原理：

实际上是分别利用了 v-bind 用来绑定 value 的值，用 v-on 去绑定 input 标准事件，这时事件用来监听当前输入域内容发生变化的时候来执行一些事情。

#### 7、v-model 用于表单数据的双向绑定，其实它就是一个语法糖，这个背后做了两个操作：

1、v-bind 绑定了 value 属性；  
2、v-on 指令给当前元素绑定 input 事件。

#### 8、vue 中的修饰符有哪些？

1、.stop：阻止事件冒泡  
2、.prevent：阻止事件默认行为  
3、.number：转为数字  
4、.enter：回车时触发  
5、.lazy：失去焦点时触发  
6、.trim：清除前后空格  
7、.once：只触发一次

#### 9、vue 中阻止事件冒泡的方法？

1、js 中原生的方法，e.stopPropagation()  
2、vue 中的修饰符.stop

#### 10、vue 中阻止默认事件的方法？

1、js 中原生的方法，e.preventDefault()  
2、vue 中的修饰符.prevent

#### 11、什么是生命周期（钩子函数）？生命周期有什么作用？说一下生命周期有哪些？第一次加载页面会触发哪几个生命周期（钩子函数）？

1、生命周期就是 vue 实例从创建到销毁的的过程。  
2、生命周期的作用就是可以帮我们在什么时间段干什么事情。  
3、生命周期最初有 10 个，废弃了 2 个，还剩下 8 个：  
①、beforeCreate：vue 实例创建之前  
②、created：vue 实例创建之后  
③、beforeMount：vue 实例 dom 加载之前  
④、mounted：vue 实例 dom 加载之后  
⑤、beforeUpdate：数据更新之前  
⑥、updated：数据更新之后  
⑦、beforeDestroy：vue 实例销毁之前  
⑧、destroyed：vue 实例销毁之后  
**工作用的最多的是 created 和 mounted**  
4、第一次啊加载页面会触发四个生命周期，分别是：  
①、beforeCreate：vue 实例创建之前 -->可以在这个里面加 loading 事件加载动画  
②、created：vue 实例创建之后 -->可以在这个里面加 loading 事件结束动画  
③、beforeMount：vue 实例 dom 加载之前  
④、mounted：vue 实例 dom 加载之后

#### 12、什么是计算属性 computed？什么是监听器 watch？两者的区别？使用场景？

1、计算属性：  
①、计算属性是 vue 提供的基于数据驱动的，依赖其它数据计算得出的值。  
2、监听器：  
①、监听器是 vue 提供的基于数据驱动的，当某个数据变化时，执行相应的操作。  
3、区别：  
①、计算属性支持缓存，不支持异步，当计算属性中存在异步操作时，无法监听到数据的变化。  
②、监听器不支持缓存，支持异步操作，可以监听到数据的变化，返回两个参数，第一个参数是新的值，第二个参数是旧的值。  
4、使用场景：  
①、计算属性使用场景：购物车商品数量计算总价  
②、监听器使用场景：监听路由的变化，监听 id 发生变化的时候调接口

#### 13、什么是过滤器？

1、过滤器就是在不改变原数据的情况下，对数据进行处理然后显示到页面上。就是在不破化原来数据的基础上生成一个新数据。  
2、使用场景：处理时间戳。

#### 14、vue 中监听不到数据的变化怎么办？

1、监听不到数据变化的第一种情况：直接修改数据或者对象的值  
解决办法：this.$set(要修改的数组/对象, 要修改的索引/属性, 要修改的值)  
2、监听不到数据变化的第二种情况：数组长度为 0，清空数据  
解决办法：直接赋值为空或者用 splice 删除

#### 15、请说一下父传子？子传父？父传子，子传父的传值方式？（组建的通讯方式有哪些？）

1、父传子：给子组件标签绑定一个自定义属性，到子组件内部通过 props 进行接收渲染数据。  
2、子传父：子组件通过 this.$emit
发送数据，然后给子组件标签绑定一个自定义方法，值为接收参数的函数，函数接受的值就是子组件传递的参数。  
3、祖辈传参：关联孙子和爷爷

```js
v - bind = "$attrs"
v - on = "$listeners"
```  

4、后代传参：  
发送数据：

```js
provide()
{
    return {
        name: '张三'
    }
}
```

接收数据：

```js
inject: ["name"];
```

#### 16、vue 组件为什么要 return 一下变量？为什么 data 是一个函数？

1、因为不使用 return 包裹数据，会在项目中变为全局可见，会造成变量的污染。使用 return
包裹后的数据，变量只能在当前组件中使用，不会影响其他组件。  
2、为什么 data 是一个函数，因为组件可能被用来创建多个实例，当我们的 data 是一个函数的时候，每一个实例的 data 都是独立的，不会互相影响了。

#### 17、父子组件调用加载顺序？

1、组件调用的顺序都是先父后子。渲染完成的顺序都是先子后父。  
2、组件销毁的顺序都是先父后子，销毁完成的顺序是先子后父。

#### 18、单页面开发（SPA）与多页面开发（MPA）的优缺点

1、单页面开发是指整个网站是由单个页面组成的；而多页面开发则是一个网站有多个页面。  
2、单页面开发的优缺点：  
优点：网站所有功能呈现于一整张页面中，用户体验较好，节省了用户时间，提高了用户的查找效率，对服务器请求较少，减轻了服务器的压力，只需要一次加载，维护成本较低。  
缺点：网站功能复杂；网站优化相对困难；构建困难，需要单独的方案。  
3、多页面开发的优缺点：  
优点：多个页面之间跳转，用户可以清晰的了解整个网站的内容构成；实现简单，开发成本低。  
缺点：页面跳转时，要重新执行 css、js 等文件页面片段之间跳转较慢，需要用到页面跨页面传值的几种方法，维护成本高。

#### 19、怎么解决组件的样式污染？

在 CSS 中加入 scoped，然后深度监听一下，::v-deep 或者/deep/

#### 20、为什么需要穿透 scoped？

UI 库看起来很美，但是，在很多项目中，会出现这么一种情况，即：引用了第三方组件，需要在组件中局部修改第三方组件的样式，而又不想去除
scoped 属性造成组件之间的样式污染（污染全局样式）。此时只能通过特殊的方式，穿透 scoped。

```
<style scoped>
外层 >>> 第三方组件 {
    样式
}
</style>
```

通过 >>> 可以使得在使用 scoped 属性的情况下，穿透 scoped，修改其他组建的值。（注意：只作用于 css）  
/deep/ 在 vue3 中会报错，如果/deep/报错，可采用 ::v-deep。（注意：只作用于 sass/scss/less）

#### 21、vue-router 有两种模式：hash 和 history 两种模式。

1、history 即地址栏没有#号。history 是最常用但是有 bug（vue 部署时使用这个模式刷新页面会报 404，配合后端修改路由刷新时的
bug）  
2、hash 即地址栏有#，（vue 部署时刷新不会报 404，但是影响美观多了#）

#### 22、非父子传参的方式

1、给 vue 的原型添加一个$observer挂载到main.js中，用this.$observer.$emit发送数据，用this.$observer.$on 接受数据。  
2、vuex

#### 23、$router 与 $route 的区别？

1、$router 对象是全局路由的实例，里面有很多路由实例的方法。比如跳转方法 push、go、back...    
2、$route 是当前组件的路由信息。包括了 url 地址信息，当前的路径，路由传递的参数。

#### 24、路由跳转方式，以及路由传值的方式。传值两种方式的区别？

1、路由跳转方式  
①、router-link 中的 to 跳转  
②、事件函数：this.$router.push({path})  
2、路由跳转传值方式：  
①、params 方式：通过路由的 name 进行传参，接收时通过 this.$route.params 接收  
②、query 方式：通过路由 path 进行传参，接收时通过 this.$route.name 接收  
3、区别：  
①、params 传参不会显示在地址栏上，安全性高，并且页面刷新数据会丢失。解决办法：本地缓存起来。  
②、query 传参会显示在地址栏上，并且页面刷新数据不会丢失。

#### 25、什么是路由守卫？路由守卫有几种？路由中的钩子函数？

1、路由守卫：路由守卫又称导航守卫，指的是路由跳转前、中、后过程中的一些钩子函数。路由跳转前做一些验证，比如：登录验证，是网站中的普遍需求。  
①、全局守卫：  
beforeEach：路由进入之前，判断是否登录  
afterEach：路由进入之后  
②、局部守卫，组件内守卫有三种：  
进入路由器前的验证，beforeRouteEnter -- 不能直接访问 this，需要 next 回调中获得  
离开路由前的验证，beforeRouteLeava -- 可以直接访问 this  
路由更新前的验证，beforeRouteUpdate  
其中路由守卫钩子函数都有三个参数：  
to：想去哪个路由  
form：从哪个路由过来的  
next：跳转到哪，执行跳转  
③、路由独享守卫  
beforeEnter 路由进入之前

#### 26、vue 怎样实现缓存？vue 项目列表跳转详情再返回列表还在原位置

1、keep-alive 缓存组件，有个 include 属性表示要缓存的组件名。  
2、缓存组件有两个生命周期：组件打开时触发，组件离开时触发。

#### 27、vue 的混入？

vue 的混入将多个 vue 文件内重复使用的功能代码，提取成单个 js 文件，在需要使用的地方进行调用即可

#### 28、知道 vuex 吗？vuex 有几种状态？分别是干什么的？

1、vuex 是一种最好的非父子传参方式，vuex 就是状态存储  
2、有五种状态：  
①、state：存储公共状态或者存储公共的数据  
②、actions：用来处理异步数据  
③、mutations：用来处理同步数据  
④、gutters：计算属性  
⑤、modules：导入 vuex 子模块  
3、你用 vuex 做过什么东西？  
左侧导航菜单

#### 29、vuex 的工作流程

当组件想要修改 state 里面的数据，首先需要调用 this.$store.dispatch 来触发 actions 里面的方法，在这个方法中会返回两个参数，一个是
commit 方法，一个是传递过来的值，然后在这个方法内部调用 commit 方法去触发 mutations 里面的函数，mutations 这个函数是专门修改存储
state 里面的数据，当 mutations 里面的函数触发后 state 里面的数据就会发生变化。就会存储到 state 中。

#### 30、怎么给 vue 中 data 添加一个属性

1、对象中添加少量新属性，可以直接采用 Vue.set()  
2、对象中添加多个新属性，则通过 Object.assign() 创建新对象  
3、如果你实在不知道怎么操作时，可采用 $forceUpdate() 及性能强制刷新

#### 31、vue 虚拟 dom？

通过 js 创建一个 Object 对象来模拟真实 DOM 结构，这个对象包含标签名 (tag)、属性 (attrs) 和子元素对象 (children) 三个属性，通过
vue 中的 render() 函数把虚拟 dom 编译成真实 dom，在通过 appendChild() 添加到页面中。创建虚拟 DOM
就是为了更好将虚拟的节点渲染到页面视图中，为什么需要虚拟 DOM， DOM 是很慢的，虚拟 dom 用来解决频繁操作 dom 而引发的浏览器卡顿问题，vue
中虚拟 DOM 最大的优势是 diff 算法，减少 JavaScript 操作真实 DOM 带来的性能消耗。

#### 32、为什么vite比较快？

1、vite利用了ES Modules的特性，无需打包，非常快。  
2、vite利用了现在浏览器对ES模块（ESM）的原生支持，当使用vite启动项目时，它会将每个模块都作为一个独立的文件提供给浏览器。  
3、vite采用了按需编译，只编译和加载当前页面所需的模块。  
4、vite会在开发过程中缓存已经编译过的模块，当模块发生改动时，只重新编译改动的模块，而不是重新编译整个项目。  
5、在开发过程中启用了热模块替换（HMR），可以在代码发生变化时实时更新页面，而无需刷新整个页面

#### 33、vue.use 和 vue.prototype 有什么区别？

1、vue.use 适用于注册专门在vue中使用的插件  
2、vue.prototype 适用于注册生态外的插件或方法

#### 34、vue自定义指令知道吗？

1、全局自定义指令 Vue.directive
2、局部 directive

#### 35、用过哪些 ui 框架？

element ui，element plus，antDesign，TDesign

#### 36、vue的入口文件，页面的入口文件，路由的出口

main.js app.vue <router-view />

#### 37、动态添加路由。

```js
let obj = {
    path: "/login",
    name: "login",
    component: () => import(/* webpackChunkName: "about" */ '../views/login.vue')
}

router.addRoute(obj)
```

#### 38、按钮权限

菜单权限(RBAC)
//后端登录成功之后，返回用户信息，其中就有用户权限，将权限数组的每一项和后端返回的路由一一对比，过滤出符合的路由，再通过addRoute动态添加路由，从而实现菜单权限

```js
// 假设有一个菜单数据数组和一个角色权限数组
let menus = [
    { id: 1, name: '首页', url: '/home', icon: 'home' },
    { id: 2, name: '用户管理', url: '/users', icon: 'user' },
    { id: 3, name: '角色管理', url: '/roles', icon: 'role' }
];
let roles = [
    { id: 1, name: '管理员', permissions: ['/home', '/users'] }
];
// 根据角色权限过滤菜单
function filterMenuByRole(menus, roles) {
    let rolePermissions = roles.reduce((acc, role) => {
        return [...acc, ...role.permissions];
    }, []);
 
    return menus.filter(menu => rolePermissions.includes(menu.url));
}
// 使用示例
let filteredMenus = filterMenuByRole(menus, roles);
console.log(filteredMenus); // 输出：过滤后应该显示的菜单列表
router.addRoutes(filteredMenus) // 动态添加可访问路由表
```

#### 39、获取不到dom元素怎么办？

```js
this.$nextTick(() => {})
```

#### 40、插槽有哪几种？

匿名插槽，具名插槽，作用域插槽

#### 41、路由的懒加载原理

```js
component: () => import(/* webpackChunkName: "about" */ '../components/hello.vue')
```

#### 42、nextTick的原理

nextTick() 的实现原理是基于 JavaScript 的事件循环机制和微任务（microtask）队列

#### 43、vuex四个辅助函数

mapState, mapMutations, mapGetters, mapActions

#### 44、vue中的路由是什么？

Vue中的路由是指我们定义的URL与相关组件之间的映射关系。通过Vue Router，我们可以构建单页面应用（SPA），使得用户可以通过不同的URL访问不同的内容，而不需要重新加载整个页面。

#### 45、中央事件总线。

可以实现非父子传参

```js
// main.js
Vue.prototype.$bus = new Vue()

// father
this.$bus.$emit("toBus", "value")

// son
this.$bus.$on('toBus',(value) => {
    console.log(value)
})
```

#### 46、Vue2 语法有什么缺陷？

1、不能检测到对象属性的添加或删除。如果需要动态添加新的响应式属性，则必须使用 Vue.set 或者 vm.$set 方法  
2、直接通过索引修改数组元素或修改数组长度不会触发视图更新