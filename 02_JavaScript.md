#### 1、什么是 JavaScript？JavaScript 是单线程还是多线程的？

JavaScript 是一种脚本语言，它运行在浏览器中，是单线程的。

#### 2、数据类型有哪些？怎样判断数据类型？

①基本数据类型：string、number、boolean。  
②复合引用数据类型：object、array、function。
③特殊数据类型：null、undefined、NaN。  
④判断数据类型：typeof 判断除数组外的数据类型；Array.isArray 判断数组数据类型；isNaN 判断不是一个数字。

#### 3、在 JavaScript 中，=、==、=== 有什么区别？

①=：赋值运算符，将右边的值赋值给左边。  
②==：比较运算符，比较两个值是否相等，会进行类型转换。  
③===：比较运算符，比较两个值是否相等，不会进行类型转换。

#### 4、i++ 和 ++i 的区别？

①i++：先赋值，后加一。  
②++i：先加一，后赋值。

#### 5、do while 和 while 的区别？

①do while：先执行一次循环体，然后再判断条件。  
②while：先判断条件，再执行循环体。

#### 6、break 和 continue 的区别？

①break：终止循环。  
②continue：跳出当前循环，继续下一次循环。

#### 7、九九乘法表。

```javascript
for (let i = 1; i <= 9; i++) {
    for (let j = 1; j <= i; j++) {
        console.log(j + '*' + i + '=' + j * i);
    }
}
```

#### 8、知不知道递归函数？递归函数经常用吗？递归函数的缺点？

①递归函数：自己调用自己的函数。  
②公司明文规定禁止使用递归函数。  
③递归函数必须要等最后一次的结果出现才能完成逻辑执行，违背了内存管理机制。

#### 9、用过闭包函数吗？什么是闭包函数？闭包函数有什么优缺点？内存泄漏？js的回收机制？

①闭包函数：在函数内部定义的函数。  
②优点：可以重复使用变量，不会造成变量污染。缺点：容易造成内存泄漏。  
③内存泄漏：指一块被分配的内存既不能使用，又不能回收，直到浏览器进程结束。  
④JS 的回收机制：JavaScript 垃圾回收的机制很简单：找出不使用的变量，然后释放掉其占用的内存。js
中最常用的垃圾回收方式就是标记清除。比如在函数中声明一个变量，就将这个变量标记为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其标记为“离开环境”。

#### 10、如何避免闭包引起的内存泄漏？哪些操作会造成内存泄漏？

①注意程序逻辑，避免死循环；减少不必要的全局变量，在使用完后赋值为空；避免创建过多的空对象。  
②意外的全局变量；脱离DOM的元素引用；未清除的定时器；闭包函数；console.log()。

#### 11、什么是命名函数？匿名函数？递归函数？回调函数？函数表达式？构造函数？闭包函数？

①命名函数：有名字的函数。  
②匿名函数：没有名字的函数。  
③递归函数：自己调用自己的函数。  
④回调函数：函数作为参数传递给另一个函数。  
⑤函数表达式：带有变量的函数，用变量调用的函数。  
⑥构造函数：用 new 关键字调用的函数。  
⑦闭包函数：能够读取函数内部变量的函数，函数内部定义的函数。

#### 12、for 与 forEach 的区别？

forEach 的返回值为 undefined，不用使用 break 和 continue 来终止或跳出循环。

#### 13、什么是全局变量？什么是局部变量？

①全局变量：在函数体外声明的变量是全局变量，省略 var 声明的变量是全局变量。全局变量在函数体内外都可以使用。  
②局部变量：在函数体内部声明的变量是局部变量。局部变量只能在函数体内部使用。

#### 14、什么是预解析？

在预解析中，变量的提升，只会在当前作用域中提升，提升到当前作用域的最上方。函数的变量只会提升到函数作用域的最前方。

#### 15、请说一下数组的常用方法？

①push：添加元素到最后。  
②pop：删除最后一个元素。  
③unshift：添加元素到最前。  
④shift：删除第一个元素。  
⑤slice：截取数组。  
⑥splice：删除、替换、添加元素。  
⑦concat：合并数组。  
⑧indexOf：查找元素在数组中的位置。  
⑨join：将数组元素连接成字符串。  
⑩sort：对数组进行排序。  
⑪reverse：反转数组。  
⑫filter：过滤数组。

#### 16、请说一下数组常用的方法有哪些？

①push()：添加到数组的最后  
②splice()：删除指定的元素，并在删除的位置添加元素  
③String()、toString()：将数组转为字符串  
④join()：拼接字符串，将数组用什么符号转为字符串  
⑤split()：将字符串转为数组  
⑥shift()：删除数组的第一项  
⑦pop()：删除数组的最后一项  
⑧unshift()：将内容添加到数组的开头  
⑨sort()：正序排序，从小到大  
⑩concat()：合并数组  
reverse()：反转  
indexOf()：方法返回数组中第一次出现给定元素的下标，如果不存在则返回 -1

#### 17、请说获取 dom 方法有几种？

1、document.getElementById("id 选择器")：获取单个元素  
2、document.getElementsByTagName("标签名")：获取的是一组数据，伪数组，注意：s  
3、document.getElementByName("name 名称")：获取的是一组数据，伪数组。注意：s  
4、document.getElementsByClassName("类名选择器")：获取的是一组数据，伪数组。注意：s  
5、document.querySelector("选择器")：通过选择器获取单个节点  
6、document.querySelectorAll("选择器")：通过选择器获取多个节点。伪数组，可以通过下标取值。  
7、parentNode：父节点  
8、children：子节点  
9、兄弟节点、事件委托等

#### 18、dom 操作的方法？

1、appendChild：添加节点到最后  
2、insertBefore：在某个位置插入  
3、removeChild：删除子节点  
4、replaceChild：修改子节点  
5、cloneNode：复制克隆节点

#### 19、获取设置类名的方法？

1、className：获取或者设置类名，其中设置的类名会覆盖原来的类名。所以设置类名的时候要把之前的类名也加上  
2、.classList.add("")：添加类名  
3、.classList.remove("")：移除类名

#### 20、innerHTML 和 innerText 的区别？

1、相同点：都可以获取或者设置内容    
2、不同点：  
①、innerHTML：以代码的形式设置/获取内容  
②、innerText：以文本的形式设置/获取内容

#### 21、js 获取或者设置属性的方法

1、通过 dom 进行获取或者设置属性.dom.属性  
2、通过 getAttribute()：获取自定义属性  
3、通过 setAttribute()：设置自定义属性

#### 22、怎样提升浏览器的加载速度

1、文件的外部引入  
2、减少冗余代码，将代码进行封装  
3、使用事件委托代替 dom 获取，减少 dom 操作  
4、图片的懒加载  
5、压缩文件

#### 23、什么是事件冒泡？怎样阻止事件冒泡？

1、两个 div 两两嵌套，都添加点击事件，我点击里面的 div 的时候，外面的 div 事件也会触发  
2、js 中阻止事件冒泡的方法：e.stopPropagation()；jq 中阻止事件冒泡的方法 return false

#### 24、事件绑定，解绑的方法

1、addEventListener：事件绑定  
2、removeEventListener：事件解绑

#### 25、什么是 window 对象？什么是 document 对象？

1、window 对象也就是 BOM，也就是浏览器对象：window 对象封装了窗口标题，工具栏按钮，地址栏，状态栏等等。都是 window
的成员对象。（window 就是 BOM 也就是浏览器）  
2、document 对象也就是 DOM，代表的是 html 整个的文档，可以用来访问网页中的所有元素，dom 属于 window 对象的一部分。（document
就是 dom，也就是网页）

#### 26、for in 和 for of 有什么区别？for of 为什么遍历对象会报错？

1、for in 遍历数组得到的是索引，遍历对象得到的是属性，不能遍历 map 对象；for of 遍历数组得到的是值，遍历对象会报错。  
2、因为没有引入 iterable，需要加上 Object.keys()，Object.values()才能使用，遍历 map 对象得到的是属性和值。

#### 27、说一下你对 this 的理解：

1、在浏览器中，在全局范围内，this 指向的是 window  
2、在普通函数中，this 指向的是调用者  
3、在构造函数中，this 指向的是 new 出来的那个新对象  
4、call、apply、bind 中的 this 被强绑定在那个对象中  
5、在箭头函数中 this 属于当前所处的最大的对象，而不是执行时的对象。箭头函数没有自己的 this，它的 this
是继承而来；默认指向在定义它时所处的对象（宿主对象），此处指父级作用域，而不是执行时的对象。

#### 28、用过深拷贝，浅拷贝吗？深拷贝和浅拷贝的区别？如何实现深拷贝？浅拷贝？JSON 深拷贝的弊端及解决方案。

1、深拷贝：就是 b 复制了 a，当修改 a 的时候，b 不会随着 a
的变化而变化，拥有独立的内存。将数据中的所有数组拷贝下来，对拷贝之后的数据进行修改不会影响到原数据。  
2、浅拷贝就是 b 复制了 a，当修改 a 的时候，b 中的子元素不会随着 a 的变化而变化，但是 b 中的子对象中的元素会随着 a
的变化而变化。原数据和复制后的数据的第一层不会改变，第二层或者深层会改变  
3、浅拷贝的方法：  
①、slice  
②、concat  
③、es6 剩余运算符  
4、深拷贝：  
①、JSON.parse()、JSON.stringify()  
②、jq 的 extend 方法  
③、通过递归去拷贝所有的层级  
5、JSON 弊端  
①、如果 obj 里面存在时间对象，通过 JSON 方法会导致时间对象变成了字符串。  
②、如果 obj 里面有 RegExp、Error 对象，转化后的结果是空对象。  
③、如果 obj 里面有函数，undefined，则序列化的结果会把函数，undefined 丢失。  
④、如果 obj 里面有 NaN，Infinity 和-Infinity，则序列化的结果会变成 null。  
⑤、JSON.stringify()只能序列化对象的可枚举的自有属性。如果 obj 中的对象是有构造函数生成的，则使用 JSON.parse(JSON.stringify(
obj))深拷贝后，会丢弃对象的 constructor。  
⑥、如果对象中存在循环引用的情况也无法正确实现深拷贝。  
6、解决：递归实现深拷贝

#### 29、什么是面向对象？面向对象的特点？

1、面向对象是一种编程思想，是由属性和方法组成的。  
2、面向对象的特点：封装、继承、多态。

#### 30、什么是构造函数？构造函数帮我们干了哪两件事？

1、用 new 关键字调用的函数称为构造函数  
2、  
①、帮我们创建了一个空对象  
②、将结果返回出去

#### 31、面向对象的继承方式？

1、call 或 apply 方法  
2、原型链 prototype  
3、利用空对象作为中介

#### 32、什么是异步？什么是同步？

1、同步可以理解为在执行完一个函数或者方法之后，一直到等待系统的返回值或者消息，之后接收到返回值或者消息之后才往下执行其他的命令。具有等待功能。  
2、异步，执行完函数或者方法之后，不必等待系统的返回值或者西消息，就可以直接执行下一个命令。不用等待。

#### 33、对promise的理解？

promise是用来解决回调地狱的，有三种状态fulfilled rejected pending，状态一旦发生改变就不可逆，promise接收了一个回调函数，函数里接受了两个参数resolve
reject，resolve是将成功的结果返回出去，reject是将失败的结果返回出去。promise有三个方法 .then .catch .finally

#### 34、http 定义？http 的三次握手？

1、http 是一种网络传输协议，浏览器作为 http 客户端通过 url 向 http 服务器发起请求，服务器接收到请求向客户端发送响应信息。  
2、三次握手：  
①、客户端向服务端发送请求  
②、服务端接收到请求需要进行核对操作，发送的请求服务端能不能接收到，如果接收到，就向客户端返回接收到的请求信息  
③、客户端拿着服务器返回成功接收到的这个信息再去向服务器发送请求，两者才能建立联系。

#### 35、请求的方式有哪些？post 和 get 的区别？

1、delete、put、post、get 等；  
2、区别：  
（1）安全性问题：  
①、get 请求参数会被拼接在地址栏上，信息会暴露  
②、post 请求参数不可见  
（2）数据传输量：  
①、get 有长度限制  
②、post 没有  
（3）缓存问题：  
①、get 数据会被缓存  
②、post 不会

#### 36、常见的状态码：

1、200：请求成功  
2、301：资源被永久转移到其他 url  
3、400：客户端你请求语法错误  
4、401：发送的请求需要被认证  
5、403：请求的资源被服务器拒绝  
6、404：表面服务器无法找到指定的资源  
7、500：表示服务器在执行请求时发生了错误  
8、502：服务器网关出现了错误  
9、503：服务器处于停机维护状态，现在无法处理请求

#### 37、创建 ajax 的步骤

1、创建 XHRHttpRequest 对象，也就是创建一个异步调用对象  
2、创建一个 http 请求，并指定请求方法（建立连接）  
3、发送 http 请求  
4、获取返回的数据

#### 38、mouseover 与 mouseenter 的区别？

1、mouseover：鼠标指向的时候触发，当鼠标指向被选元素及其后代元素时触发，会产生事件冒泡  
2、mouseenter：鼠标指向的时候触发，当鼠标指向被选中元素时触发，不会产生时间冒泡

#### 39、什么是防抖？什么是节流？

1、防抖就是多次执行变为最后一次执行，实现函数的防抖：延时器  
2、节流就是多次执行变成每隔一段时间执行。实现函数截留的方法：定时器和时间戳

#### 40、sessionStorage，localStorage，cookie 的区别？

1、sessionStorage 生命周期为当前窗口或标签页，一旦窗口或标签页关闭，所有存储的数据也会被清空。  
2、localStorage 生命周期是永久的。除非用户手动清除信息，否则这些信息永久存在。  
3、cookie 是浏览器与服务器之间来回传递，cookie 浏览器关闭数据一直保存，只在过期时间内有效，可以设置过期时间。cookie 存储数据不能超过
4k，sessionStorage，localStorage 存储的数据可以是 5M，甚至更多。

#### 41、var、let、const 的区别？

1、var 声明的变量属于全局变量，属于 window，var 声明的变量可以声明多次，可以修改，并且 var 声明的变量存在变量的提升。  
2、let 只在块级作用域中使用，即{}，不存在变量提升，let 只能声明一次不能重复定义，let 声明的变量存在暂时性死区。  
3、const 声明一个只读常量，声明之后不允许改变，而且必须初始化，const 定义的基本数据是不可以改变的，但是定义的对象或者是数组可以通过下标或者属性来修改

#### 42、为什么 const 可以修改对象或者数组？

1、const 指针指向的地址是不可以改变的，但是地址的内容是可以改变的

#### 43、es6 中如何实现数组去重？

1、用 new Set(数组)实现去重

#### 44、怎样将伪数组转为数组？

1、Array.from 或者剩余运算符去将伪数组转成数组
然后用数组的方法去实现逻辑

#### 45、es6 的新特性

1、新的声明方式  
2、解构性赋值，剩余运算符  
3、数组的遍历方法 for of，find 等方法  
4、箭头函数  
5、symbol，set 去重，map 方法，字符串模板，promise，模块化  
6、class 和 extends，super 调用父类的方法

#### 46、谈谈 async/await 的使用方式和场景

1、async 是用来修饰函数的声明，使用 async 修改的函数会变成一个异步函数，可以使用 then 来接受参数  
2、await 用来修饰函数的调用，被 await 修改的函数返回一个 promise 异步对象，使用 await 修饰后，就会将 promise
异步对象转换成一个同步操作。其中直接提取 resolve 里面的值。

#### 47、箭头函数有什么作用及实际应用场景？

1、箭头函数的作用：  
①、箭头函数的语法比函数表达式更简洁  
②、箭头函数可以解决 this 指向问题。箭头函数不会创建自己的 this，它只会从自己的作用域链向上一层继承 this。  
2、箭头函数的使用场景：  
①、简单的函数表达式，内部没有 this 引用，没有递归，事件绑定，解绑定。  
②、需要调用 this，且 this 指向和上一层作用域链保持一致时。如保证指向 vue 实例对象。

#### 48、class 类如何实现继承，简单实现？

子类继承父类——语法：class 子类 extend 父类，在子类的构造方法中使用 super 调用父类的构造方法。

#### 49、什么是跨域？解决跨域？

1、跨域指的是：浏览器不能执行其它网站的脚本，从一个域名的网页去请求另一个域名的资源时，域名、端口、协议任一不同，都是跨域。跨域是由于浏览器的同源策略造成的，是浏览器施加的安全限制  
2、解决：  
①、设置跨域代理、在 vue 中的 config.js 中设置 proxy 设置  
②、jsonp  
③、后端处理  
④、借调

#### 50、事件循环机制

js 是单线程语言，一次只能完成一个任务，如果同时完成多个任务怎么办？js
把任务分为同步和异步任务，把所有的同步放到主线程上去执行，把所有的异步任务方法事件队列里去，当所有的同步任务都执行完之后，去事件队列中看看有没有没有执行的异步任务，如果有，把需要执行的异步任务拉到主线程上去执行，当这个任务执行完后，再去事件队列里看有没有没有完成的任务，如果有，再把主任务拉到主线程去执行，这样就形成了要给事件循环。

#### 51、宏任务和微任务？

浏览器的事件循环（event loop）中分成宏任务和微任务。JS 中分成同步任务和异步任务。  
1、宏任务：JS 中主栈执行的大多数任务，例如：定时器，事件绑定，ajax，回调函数，node 中 fs 操作模块等任务就是宏任务。  
2、微任务：promise，async/await，process，nextTick 等就是微任务。

#### 52、图片的懒加载

懒加载也就是延迟加载。有时候一个网页会包含很多的图片，例如：京东、淘宝这些购物网站，商品图片多只又多，页面图片多，加载的图片就多。服务器压力就会很大。不仅影响渲染速度还会浪费带宽。比如一个
1M 大小的图片，并发情况下，达到 1000 并发，即同时有 1000 个人访问，就会产生 1 个 G 的带宽。

#### 53、懒加载原理

一张图片就是一个<img>标签，浏览器是否发起请求图片是根据<img>的 src
属性，所以实现懒加载的关键就是，在图片没有进入可视区域时，先不给<img>的 src 赋值，这样浏览器就不会发送请求了，等到图片进入可视区域再给
src 赋值。

#### 54、懒加载思路及实现

实现懒加载有四个步骤，如下：  
1、加载 loading 图片  
2、判断哪些图片要加载【重点】  
3、隐形加载图片  
4、替换真图片

#### 55、常用方法

1、转数字：  
Number()  
2、转字符串：  
toStrong()  
String()  
3、保留两位小数：  
toFixed()  
4、数组转字符串方法：  
String()、toString()、join()  
5、字符串转数组：  
split()  
6、字符截取：  
substring()  
substr()  
7、字符串修改：  
replace()  
8、json 字符串转 json 对象：  
JSON.parse()  
9、json 对象转字符串：  
JSON.stringify()  
10、检测字符串开头：starWith  
11、检测字符串结尾：endWith  
12、字符串前面填充：padStart()  
13、字符串后面填充：padEnd()

#### 56、NaN 和 NaN 全等于结果是什么？

结果是 false，因为 NaN 表示不确定性。

#### 57、什么是原型链？

当访问一个对象属性时，如果对象内部不存在这个属性，那么就会去它的__porto__属性所指的那个对象（可以理解为父对象）里找，如果父对象也不存在这个属性，则继续往父对象的__proto__属性所指的那个对象（可以理解为爷爷对象）里找，如果还没找到，则继续往上找……直到原型链顶端null（可以理解为原始人），再往上找就相当于在null上取值，（可以理解为，再往上找就已经不是“人”的范畴了，找不到了，到此结束，null为原型链的终点），由以上这种通过__proto__属性来连接对象直到null的一条链即为我们所谓的原型链。

#### 58、怎么改变this指向？

call apply bind

#### 59、call apply bind 的区别？

function.call(thisArg, arg1, arg2, ...)  
function.apply(thisArg, [ArgsArray])  
function.bind(thisArg, arg1, arg2, ...)  
call 和 apply 都是直接调用函数，他俩的区别在于传入参数的方式，call是逗号间隔，apply是数组形式。  
bind()需要手动调用一下

#### 60、js内置构造函数？

new Data，new Promise，new Array，new Object，new String，new Number...

#### 61、栈溢出的解决办法？

1、优化递归，设置正确中止条件。
2、过渡嵌套回调函数。

#### 62、怎么解决数据精度问题？

toFixed()

#### 63、怎么判断引用数据类型？

1、Array.isArray 判断是不是数组  
2、instanceof

#### 64、浏览器渲染机制？

当在浏览器地址栏输入网址时，首先会将域名解析成ip，浏览器向服务器发送请求，服务器将内容发送给浏览器，浏览器先渲染生产dom树和css树，将内容渲染到页面.

#### 65、http 和 https 的区别？

1、https 是 http 的安全版本，https 加密传输数据，http 明文传输数据。
2、https 默认端口是 443，http 默认端口是 80。

#### 66、接口文档都有什么内容？

有接口名称，功能，请求方法，请求参数，响应参数，错误码列表等详细信息。

#### 67、e.target 和 e.currentTarget 的区别？

1、e.target：表示当前被触发事件的目标元素，即触发事件的元素本身。
2、e.currentTarget：表示当前事件处理函数所在的目标元素，即事件处理函数所在的元素本身。

#### 68、js 中的key可以是一个对象吗？

在 JavaScript 中，对象不能作为对象的键（key）。但是，实际上 JavaScript 的对象键会被自动转换为字符串。如果你尝试将一个对象作为键，JavaScript
会将其转换为字符串 [object Object]
。这意味着，如果你在对象中使用多个不同的对象作为键，它们会变成相同的字符串 [object Object]，从而导致键冲突。

### 69、缓存使用 cookie 时要设置哪些属性？

1、名称和值； 2、过期时间； 3、作用域； 4、安全属性； 5、SameSite属性；